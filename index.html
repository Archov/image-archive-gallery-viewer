<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kemono Archive Gallery</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .app-header {
            background: #2d2d2d;
            padding: 15px;
            border-bottom: 2px solid #444;
            display: flex;
            align-items: center;
            gap: 15px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 70px;
        }

        .history-btn, .settings-btn {
            padding: 8px 12px;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .history-btn:hover, .settings-btn:hover {
            background: #666;
        }

        .url-input {
            flex: 1;
            padding: 10px 15px;
            background: #333;
            border: 2px solid #555;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
        }

        .url-input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .load-btn {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .load-btn:hover {
            background: #45a049;
        }

        .load-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .status {
            font-size: 12px;
            color: #ccc;
            min-width: 200px;
            text-align: right;
        }

        .main-content {
            margin-top: 70px;
            height: calc(100vh - 70px);
            overflow-y: auto;
        }

        .welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #888;
        }

        .welcome h1 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #e0e0e0;
        }

        .welcome p {
            font-size: 18px;
            max-width: 600px;
            line-height: 1.6;
        }

        /* Gallery styles - matching the userscript */
        .gallery-container {
            display: none;
            height: 100%;
        }

        .gallery-controls {
            background: #2d2d2d;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .gallery-controls label {
            color: #e0e0e0;
            font-size: 14px;
        }

        .gallery-controls input[type="range"] {
            width: 80px;
        }

        .gallery-controls span {
            color: #e0e0e0;
            min-width: 30px;
            font-size: 14px;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            padding: 15px;
            background: #1a1a1a;
        }

        .gallery-grid img {
            width: 100%;
            height: auto;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid #333;
            transition: transform 0.25s ease;
        }

        .gallery-grid img:hover {
            transform: scale(1.05);
            z-index: 10;
            position: relative;
        }

        /* Fullscreen viewer */
        .fullscreen-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .fullscreen-image {
            max-width: 95vw;
            max-height: 95vh;
            object-fit: contain;
        }

        .fullscreen-image.allow-upscaling {
            max-width: none;
            max-height: none;
            width: 100vw;
            height: 100vh;
            object-fit: contain;
        }

        .fullscreen-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-nav:hover {
            background: rgba(255,255,255,0.3);
        }

        .fullscreen-prev {
            left: 20px;
        }

        .fullscreen-next {
            right: 20px;
        }

        .fullscreen-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }

        .fullscreen-counter {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }

        .loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px 40px;
            border-radius: 15px;
            z-index: 20000;
            text-align: center;
            border: 3px solid #4CAF50;
            min-width: 300px;
        }

        .loading h3 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        .loading p {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .loading .progress-container {
            margin: 15px 0;
        }

        .loading .progress-bar {
            width: 100%;
            height: 8px;
            background: #555;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .loading .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .loading .progress-text {
            font-size: 12px;
            color: #ccc;
            text-align: center;
        }

        .archive-loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            z-index: 20000;
            text-align: center;
            border: 2px solid #4CAF50;
            display: none;
        }

        .archive-loading h4 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .archive-loading p {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .archive-title {
            font-weight: bold;
            color: #4CAF50;
            margin-right: 20px;
        }

        /* History Panel */
        .history-panel {
            position: fixed;
            top: 70px;
            left: 0;
            width: 400px;
            height: calc(100vh - 70px);
            background: #2d2d2d;
            border-right: 2px solid #444;
            z-index: 500;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
        }

        .history-panel.open {
            transform: translateX(0);
        }

        .history-header {
            padding: 15px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .history-controls button {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            color: #4CAF50;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .history-controls button:hover {
            background: rgba(76, 175, 80, 0.2);
        }

        .history-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .history-item {
            padding: 12px 15px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .history-checkbox {
            width: 16px;
            height: 16px;
            background: #333;
            border: 2px solid #555;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }

        .history-checkbox:hover {
            border-color: #4CAF50;
        }

        .history-checkbox.checked {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .history-checkbox.checked::after {
            content: 'âœ“';
            position: absolute;
            top: -2px;
            left: 1px;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .history-item:hover {
            background: #3a3a3a;
        }

        .history-item-star {
            color: #ccc;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .history-item-star:hover {
            background: #555;
        }

        .history-item.current-archive {
            background: rgba(76, 175, 80, 0.3);
            border-left: 4px solid #4CAF50;
            color: #e0e0e0;
        }

        .history-item-starred .history-item-star {
            color: #ffd700;
        }

        /* Rename functionality */
        .history-item:hover .history-item-rename {
            opacity: 1;
        }

        .history-item-rename {
            opacity: 0;
            margin-left: 8px;
            padding: 2px 6px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            color: #4CAF50;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }

        .history-item-rename:hover {
            background: rgba(76, 175, 80, 0.2);
        }

        .history-rename-input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #4CAF50;
            border-radius: 3px;
            background: #333;
            color: #fff;
            font-size: 12px;
        }

        /* Drag and drop reordering */
        .history-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .history-item.drag-over {
            border-top: 2px solid #4CAF50;
            margin-top: -2px;
        }

        .history-drag-handle {
            cursor: grab;
            padding: 4px;
            margin-right: 8px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .history-item:hover .history-drag-handle {
            opacity: 1;
        }

        .history-drag-handle:active {
            cursor: grabbing;
        }

        .history-drag-handle::before {
            content: 'â‹®â‹®';
            font-size: 12px;
            line-height: 1;
        }

        .history-item-info {
            flex: 1;
            min-width: 0;
        }

        .history-item-name {
            font-weight: bold;
            color: #e0e0e0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .history-item-details {
            font-size: 12px;
            color: #aaa;
            margin-top: 4px;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 70px;
            right: 0;
            width: 350px;
            height: calc(100vh - 70px);
            background: #2d2d2d;
            border-left: 2px solid #444;
            z-index: 500;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-header {
            padding: 15px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-group {
            padding: 20px 15px;
            border-bottom: 1px solid #333;
        }

        .settings-group h3 {
            margin-bottom: 15px;
            color: #e0e0e0;
            font-size: 16px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .setting-item input[type="number"], .setting-item select {
            width: 100%;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }

        .setting-item input[type="number"]:focus, .setting-item select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .cache-info {
            background: #333;
            padding: 12px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .cache-info div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .cache-info div:last-child {
            margin-bottom: 0;
        }

        .cache-bar {
            height: 8px;
            background: #555;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .cache-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.3s ease;
        }

        /* Star button in gallery */
        .gallery-grid .image-container {
            position: relative;
        }

        .gallery-grid .star-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: #ccc;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            opacity: 0;
            transition: all 0.2s;
            z-index: 50;
        }

        .gallery-grid .image-container:hover .star-btn {
            opacity: 1;
        }

        .gallery-grid .star-btn:hover {
            background: rgba(0,0,0,0.9);
        }

        .gallery-grid .star-btn.starred {
            color: #ffd700;
            opacity: 1;
        }

        /* Backup management styles */
        .setting-section h4 {
            margin: 20px 0 10px 0;
            color: #4CAF50;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .backup-btn {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            color: #4CAF50;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .backup-btn:hover {
            background: rgba(76, 175, 80, 0.2);
        }

        .backup-list {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        .backup-list h5 {
            margin: 0 0 10px 0;
            color: #e0e0e0;
            font-size: 13px;
        }

        .backup-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
        }

        .backup-info {
            flex: 1;
        }

        .backup-filename {
            font-weight: bold;
            color: #ccc;
            font-size: 12px;
        }

        .backup-timestamp {
            font-size: 11px;
            color: #888;
        }

        .restore-btn {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid #2196F3;
            color: #2196F3;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .restore-btn:hover {
            background: rgba(33, 150, 243, 0.2);
        }

        /* Drag and drop styling */
        body.drag-over {
            background: #2a2a2a;
        }

        body.drag-over::after {
            content: 'Drop archive file or URL here';
            position: fixed;
            inset: 0;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            z-index: 100000;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="app-header">
        <button class="history-btn" id="historyBtn">Library</button>
        <button class="settings-btn" id="settingsBtn">Settings</button>
        <input type="text" class="url-input" placeholder="Paste archive URL here or drag & drop files/links..." id="urlInput">
        <button class="load-btn" id="loadBtn">Load Archive</button>
        <div class="status" id="status">Ready</div>
    </div>

    <div class="main-content">
        <div class="welcome" id="welcome">
            <h1>ðŸ“¦ Kemono Archive Gallery</h1>
            <p>Paste any ZIP, RAR, or 7Z archive URL above to view images in a gallery format. Supports all the same navigation features as the web version: column controls, hover zoom, arrow keys, and scroll wheel navigation in fullscreen mode.</p>
            <p style="margin-top: 20px; color: #888; font-size: 14px;">
                You can also drag and drop archive files or URLs directly onto this window.
            </p>
        </div>

        <div class="gallery-container" id="galleryContainer">
            <div class="gallery-controls">
                <span class="archive-title" id="archiveTitle"></span>
                <label>Columns:</label>
                <input type="range" id="columnSlider" min="2" max="8" value="5">
                <span id="columnValue">5</span>
                
                <label>Hover Zoom:</label>
                <input type="range" id="zoomSlider" min="100" max="200" value="100">
                <span id="zoomValue">100%</span>
                
                <button class="load-btn" onclick="showWelcome()" style="margin-left: auto;">New Archive</button>
            </div>
            <div class="gallery-grid" id="galleryGrid"></div>
        </div>
    </div>

    <!-- History Panel -->
    <div class="history-panel" id="historyPanel">
        <div class="history-header">
            <h3 style="margin: 0; color: #e0e0e0;">Library</h3>
            <button class="load-btn" onclick="clearHistory()" style="font-size: 12px; padding: 4px 8px;">Clear All</button>
        </div>
        <div class="history-controls">
            <button onclick="selectAllHistory()">Select All</button>
            <button onclick="selectNoneHistory()">Select None</button>
            <button onclick="clearSelectedArchives()" id="clearSelectedBtn" disabled>Clear Selected</button>
        </div>
        <div class="history-list" id="historyList">
            <!-- History items will be populated here -->
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h3 style="margin: 0; color: #e0e0e0;">Settings</h3>
            <span style="font-size: 12px; color: #888;">v1.0</span>
        </div>
        
        <div class="settings-group">
            <h3>Cache Management</h3>
            
            <div class="setting-item">
                <label for="cacheSize">Cache Size Limit (GB)</label>
                <input type="number" id="cacheSize" min="0.5" max="50" step="0.5" value="2">
            </div>
            
            <div class="cache-info" id="cacheInfo">
                <div><span>Used:</span><span id="cacheUsed">0 MB</span></div>
                <div><span>Available:</span><span id="cacheAvailable">2.0 GB</span></div>
                <div><span>Starred Items:</span><span id="starredCount">0</span> <small style="color: #888;">(excluded from cache)</small></div>
                <div class="cache-bar">
                    <div class="cache-bar-fill" id="cacheBarFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="setting-item" style="margin-top: 15px;">
                <button class="load-btn" onclick="clearCache()" style="width: 100%;">Clear Non-Starred Cache</button>
            </div>
        </div>

        <div class="settings-group">
            <h3>General</h3>
            
            <div class="setting-item">
                <label for="autoLoadFromClipboard">Auto-load from clipboard</label>
                <select id="autoLoadFromClipboard">
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label for="maxHistoryItems">Max history items</label>
                <input type="number" id="maxHistoryItems" min="10" max="1000" value="100">
            </div>

            <div class="setting-item">
                <label for="allowFullscreenUpscaling">Allow fullscreen upscaling</label>
                <select id="allowFullscreenUpscaling">
                    <option value="false">Disabled (max 100%)</option>
                    <option value="true">Enabled (scale to fit screen)</option>
                </select>
            </div>

            <div class="setting-item">
                <label for="autoLoadAdjacentArchives">Auto-load adjacent archives</label>
                <select id="autoLoadAdjacentArchives">
                    <option value="true">Enabled</option>
                    <option value="false">Disabled</option>
                </select>
            </div>

            <div class="setting-section">
                <h4>ðŸ’¾ Database Management</h4>

                <div class="setting-item">
                    <button id="backupDatabaseBtn" class="backup-btn">Create Manual Backup</button>
                    <span id="backupStatus"></span>
                </div>

                <div class="setting-item">
                    <button id="listBackupsBtn" class="backup-btn">View Available Backups</button>
                </div>

                <div id="backupList" class="backup-list" style="display: none;">
                    <h5>Available Backups:</h5>
                    <div id="backupItems"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="fullscreen-overlay" id="fullscreenOverlay">
        <div class="fullscreen-container">
            <img class="fullscreen-image" id="fullscreenImage">
            <button class="fullscreen-nav fullscreen-prev" id="fullscreenPrev">â€¹</button>
            <button class="fullscreen-nav fullscreen-next" id="fullscreenNext">â€º</button>
            <button class="fullscreen-close" id="fullscreenClose">âœ•</button>
            <div class="fullscreen-counter" id="fullscreenCounter"></div>
        </div>
    </div>

    <div class="archive-loading" id="archiveLoading">
        <h4>Loading Archive...</h4>
        <p>Please wait while we extract the images</p>
    </div>

    <script>
        // Global state for rename mode
        let isRenaming = false;
        let currentIndex = 0;
        let currentArchiveId = null;
        let currentImages = []; // Make sure this is properly defined
        let selectedHistoryItems = new Set();
        let loadedArchiveIds = new Set(); // Track which archives are currently loaded
        let settings = {
            cacheSize: 2, // GB
            autoLoadFromClipboard: true,
            maxHistoryItems: 100,
            allowFullscreenUpscaling: false,
            autoLoadAdjacentArchives: true
        };
        let isArchiveLoading = false; // Flag to prevent multiple concurrent loads

        // DOM elements
        const urlInput = document.getElementById('urlInput');
        const loadBtn = document.getElementById('loadBtn');
        const status = document.getElementById('status');
        const welcome = document.getElementById('welcome');
        const galleryContainer = document.getElementById('galleryContainer');
        const galleryGrid = document.getElementById('galleryGrid');
        const archiveTitle = document.getElementById('archiveTitle');
        const columnSlider = document.getElementById('columnSlider');
        const columnValue = document.getElementById('columnValue');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const fullscreenOverlay = document.getElementById('fullscreenOverlay');
        const fullscreenImage = document.getElementById('fullscreenImage');
        const fullscreenCounter = document.getElementById('fullscreenCounter');
        const loading = document.getElementById('loading');
        const loadingTitle = document.getElementById('loadingTitle');
        const loadingText = document.getElementById('loadingText');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const archiveLoading = document.getElementById('archiveLoading');
        
        // Panel elements
        const historyPanel = document.getElementById('historyPanel');
        const settingsPanel = document.getElementById('settingsPanel');
        const historyList = document.getElementById('historyList');

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadSettings();
            await loadHistory();
            await updateCacheInfo();
            
            // Auto-paste from clipboard if enabled
            if (settings.autoLoadFromClipboard && navigator.clipboard) {
                navigator.clipboard.readText().then(text => {
                    if (text && isArchiveUrl(text)) {
                        urlInput.value = text;
                        updateStatus('Archive URL detected from clipboard');
                    }
                }).catch(() => {
                    // Clipboard access denied, that's fine
                });
            }

            // Event listeners
            loadBtn.addEventListener('click', loadArchive);
            urlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') loadArchive();
            });

            // Panel toggles
            document.getElementById('historyBtn').addEventListener('click', toggleHistoryPanel);
            document.getElementById('settingsBtn').addEventListener('click', toggleSettingsPanel);

            // Settings controls
            document.getElementById('cacheSize').addEventListener('change', saveSettings);
            document.getElementById('autoLoadFromClipboard').addEventListener('change', saveSettings);
            document.getElementById('maxHistoryItems').addEventListener('change', saveSettings);
            document.getElementById('allowFullscreenUpscaling').addEventListener('change', saveSettings);
            document.getElementById('autoLoadAdjacentArchives').addEventListener('change', saveSettings);

            // Backup management
            document.getElementById('backupDatabaseBtn').addEventListener('click', createManualBackup);
            document.getElementById('listBackupsBtn').addEventListener('click', listAvailableBackups);

            // Gallery controls
            columnSlider.addEventListener('input', () => {
                galleryGrid.style.gridTemplateColumns = `repeat(${columnSlider.value}, 1fr)`;
                columnValue.textContent = columnSlider.value;
            });

            zoomSlider.addEventListener('input', () => {
                zoomValue.textContent = zoomSlider.value + '%';
                updateHoverZoom();
                updateZoomSliderMax();
            });

            // Fullscreen controls
            document.getElementById('fullscreenPrev').addEventListener('click', () => navigateFullscreen(-1));
            document.getElementById('fullscreenNext').addEventListener('click', () => navigateFullscreen(1));
            document.getElementById('fullscreenClose').addEventListener('click', closeFullscreen);
            fullscreenOverlay.addEventListener('click', (e) => {
                if (e.target === fullscreenOverlay) closeFullscreen();
            });

            // Keyboard navigation
            document.addEventListener('keydown', handleKeyboard);

            // Mouse wheel navigation in fullscreen
            fullscreenOverlay.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) navigateFullscreen(1);
                else navigateFullscreen(-1);
            });
            
            // Gallery scroll event for auto-loading adjacent archives
            const debouncedScrollHandler = debounce(handleGalleryScroll, 200);
            galleryGrid.addEventListener('scroll', debouncedScrollHandler);
            
            // Also listen to main content scroll since gallery might not have its own scrollbar
            document.querySelector('.main-content').addEventListener('scroll', debouncedScrollHandler);

            // Drag and drop
            setupDragAndDrop();

            // Handle paste events
            document.addEventListener('paste', (e) => {
                if (document.activeElement === urlInput) return;
                
                const text = e.clipboardData.getData('text');
                if (text && isArchiveUrl(text)) {
                    urlInput.value = text;
                    updateStatus('Archive URL pasted');
                }
            });

            // Close panels when clicking outside
            document.addEventListener('click', (e) => {
                if (!historyPanel.contains(e.target) && !document.getElementById('historyBtn').contains(e.target)) {
                    historyPanel.classList.remove('open');
                }
                if (!settingsPanel.contains(e.target) && !document.getElementById('settingsBtn').contains(e.target)) {
                    settingsPanel.classList.remove('open');
                }
            });
        });

        function setupDragAndDrop() {
            let dragCounter = 0;

            document.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                document.body.classList.add('drag-over');
            });

            document.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    document.body.classList.remove('drag-over');
                }
            });

            document.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            document.addEventListener('drop', async (e) => {
                e.preventDefault();
                dragCounter = 0;
                document.body.classList.remove('drag-over');

                const files = e.dataTransfer.files;
                const text = e.dataTransfer.getData('text');

                if (files.length > 0) {
                    // Handle file drop
                    const file = files[0];
                    if (isArchiveFile(file.name)) {
                        try {
                            const images = await window.electronAPI.loadLocalArchive(file.path);
                            if (images && images.length > 0) {
                                displayGallery(images, file.name);
                                await addToHistory(file.name, `file://${file.path}`, images.length);
                                updateStatus(`Loaded ${images.length} images from local file`);
                            } else {
                                updateStatus('No images found in dropped file', true);
                            }
                        } catch (error) {
                            updateStatus(`Error loading file: ${error.message}`, true);
                        }
                    } else {
                        updateStatus('Dropped file is not a supported archive format', true);
                    }
                } else if (text && isArchiveUrl(text)) {
                    // Handle URL drop
                    urlInput.value = text;
                    updateStatus('Archive URL dropped');
                    loadArchive();
                }
            });
        }

        function toggleHistoryPanel() {
            historyPanel.classList.toggle('open');
            settingsPanel.classList.remove('open');
        }

        function toggleSettingsPanel() {
            settingsPanel.classList.toggle('open');
            historyPanel.classList.remove('open');
        }

        async function loadSettings() {
            try {
                const savedSettings = await window.electronAPI.loadSettings();
                if (savedSettings) {
                    settings = { ...settings, ...savedSettings };
                    
                    // Apply settings to UI
                    document.getElementById('cacheSize').value = settings.cacheSize;
                    document.getElementById('autoLoadFromClipboard').value = settings.autoLoadFromClipboard.toString();
                    document.getElementById('maxHistoryItems').value = settings.maxHistoryItems;
                    document.getElementById('allowFullscreenUpscaling').value = settings.allowFullscreenUpscaling.toString();
                    document.getElementById('autoLoadAdjacentArchives').value = settings.autoLoadAdjacentArchives.toString();
                    
                    // Apply fullscreen upscaling setting
                    updateFullscreenUpscaling();
                    updateZoomSliderMax();
                }
            } catch (error) {
                console.warn('Failed to load settings:', error);
            }
        }

        async function saveSettings() {
            settings.cacheSize = parseFloat(document.getElementById('cacheSize').value);
            settings.autoLoadFromClipboard = document.getElementById('autoLoadFromClipboard').value === 'true';
            settings.maxHistoryItems = parseInt(document.getElementById('maxHistoryItems').value);
            settings.allowFullscreenUpscaling = document.getElementById('allowFullscreenUpscaling').value === 'true';
            settings.autoLoadAdjacentArchives = document.getElementById('autoLoadAdjacentArchives').value === 'true';
            
            try {
                await window.electronAPI.saveSettings(settings);
                await updateCacheInfo();
                updateFullscreenUpscaling();
                updateZoomSliderMax();
            } catch (error) {
                console.error('Failed to save settings:', error);
            }
        }

        async function loadHistory() {
            try {
                const history = await window.electronAPI.loadHistory();
                renderHistory(history);
            } catch (error) {
                console.warn('Failed to load history:', error);
            }
        }

        function renderHistory(history) {
            historyList.innerHTML = '';
            
            history.forEach((item, index) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.draggable = !isRenaming; // Only draggable when not renaming
                historyItem.dataset.historyId = item.id;
                
                // Highlight current archive or loaded archives
                const itemArchiveId = getArchiveIdFromUrl(item.url);
                if (loadedArchiveIds.has(itemArchiveId)) {
                    historyItem.classList.add('current-archive');
                }
                
                // Checkbox for selection
                const checkbox = document.createElement('div');
                checkbox.className = `history-checkbox ${selectedHistoryItems.has(item.id) ? 'checked' : ''}`;
                checkbox.title = 'Select for batch loading';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    toggleHistorySelection(item.id);
                };
                
                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'history-drag-handle';
                dragHandle.title = 'Drag to reorder';
                
                // Star button
                const star = document.createElement('div');
                star.className = `history-item-star ${item.starred ? 'starred' : ''}`;
                star.innerHTML = item.starred ? 'â˜…' : 'â˜†';
                star.title = item.starred ? 'Remove from favorites' : 'Add to favorites';
                star.onclick = (e) => {
                    e.stopPropagation();
                    toggleHistoryStar(item.id);
                };
                
                // Info section
                const info = document.createElement('div');
                info.className = 'history-item-info';
                
                const name = document.createElement('div');
                name.className = 'history-item-name';
                name.textContent = item.name;
                
                const details = document.createElement('div');
                details.className = 'history-item-details';
                details.textContent = `${item.imageCount} images â€¢ ${new Date(item.lastAccessed).toLocaleDateString()}`;
                
                // Rename button
                const renameBtn = document.createElement('button');
                renameBtn.className = 'history-item-rename';
                renameBtn.textContent = 'âœï¸';
                renameBtn.title = 'Rename';
                renameBtn.onclick = (e) => {
                    e.stopPropagation();
                    startRenameMode(historyItem, item);
                };
                
                info.appendChild(name);
                info.appendChild(details);
                
                historyItem.appendChild(checkbox);
                historyItem.appendChild(dragHandle);
                historyItem.appendChild(star);
                historyItem.appendChild(info);
                historyItem.appendChild(renameBtn);
                
                // Drag and drop events
                historyItem.addEventListener('dragstart', handleDragStart);
                historyItem.addEventListener('dragend', handleDragEnd);
                historyItem.addEventListener('dragover', handleDragOver);
                historyItem.addEventListener('drop', handleDrop);
                
                // Click on item (not on checkbox) loads single archive
                const clickableArea = info;
                clickableArea.style.cursor = 'pointer';
                clickableArea.onclick = () => loadFromHistory(item);
                
                historyList.appendChild(historyItem);
            });
            
            updateClearSelectedButton();
        }

        function getArchiveIdFromUrl(url) {
            // Use a simple hash function that matches what the backend would generate
            // The backend uses MD5 but we'll use a simpler hash here
            let hash = 0;
            for (let i = 0; i < url.length; i++) {
                const char = url.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            // Return as hex string, padded to ensure consistent length
            return Math.abs(hash).toString(16).padStart(16, '0');
        }

        async function addToHistory(name, url, imageCount) {
            try {
                await window.electronAPI.addToHistory({
                    name,
                    url,
                    imageCount,
                    lastAccessed: new Date().toISOString()
                });
                await loadHistory();
            } catch (error) {
                console.error('Failed to add to history:', error);
            }
        }

        async function toggleHistoryStar(historyId) {
            console.log(`=== FRONTEND HISTORY STAR TOGGLE ===`);
            console.log(`History ID: ${historyId}`);

            try {
                console.log(`Calling window.electronAPI.toggleHistoryStar(${historyId})`);
                const result = await window.electronAPI.toggleHistoryStar(historyId);
                console.log(`Backend result:`, result);

                await loadHistory();
                await updateCacheInfo();
                console.log(`=== FRONTEND HISTORY STAR TOGGLE COMPLETE ===`);
            } catch (error) {
                console.error('Failed to toggle history star:', error);
            }
        }

        async function clearHistory() {
            if (confirm('Are you sure you want to clear all history? This will not affect starred items.')) {
                try {
                    await window.electronAPI.clearHistory();
                    await loadHistory();
                } catch (error) {
                    console.error('Failed to clear history:', error);
                }
            }
        }

        // History rename functionality
        function startRenameMode(historyItem, item) {
            isRenaming = true; // Prevent dragging while renaming
            const info = historyItem.querySelector('.history-item-info');
            const nameEl = historyItem.querySelector('.history-item-name');
            const renameBtn = historyItem.querySelector('.history-item-rename');
            
            // Hide original elements
            nameEl.style.display = 'none';
            renameBtn.style.display = 'none';
            
            // Create input field
            const input = document.createElement('input');
            input.className = 'history-rename-input';
            input.value = item.name;
            input.type = 'text';
            
            // Prevent drag events on the input
            input.addEventListener('dragstart', (e) => e.preventDefault());
            input.addEventListener('drop', (e) => e.preventDefault());
            
            // Create save/cancel buttons
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'âœ“';
            saveBtn.className = 'history-item-rename';
            saveBtn.onclick = async () => {
                const newName = input.value.trim();
                if (newName && newName !== item.name) {
                    try {
                        const success = await window.electronAPI.renameHistoryItem(item.id, newName);
                        if (success) {
                            await loadHistory();
                            updateStatus(`Renamed "${item.name}" to "${newName}"`);
                        } else {
                            updateStatus('Failed to rename item', true);
                        }
                    } catch (error) {
                        console.error('Failed to rename:', error);
                        updateStatus('Failed to rename item', true);
                    }
                }
                exitRenameMode(historyItem, nameEl, renameBtn, input, saveBtn, cancelBtn);
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'âœ•';
            cancelBtn.className = 'history-item-rename';
            cancelBtn.onclick = () => {
                exitRenameMode(historyItem, nameEl, renameBtn, input, saveBtn, cancelBtn);
            };
            
            // Handle Enter/Escape keys
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveBtn.click();
                } else if (e.key === 'Escape') {
                    cancelBtn.click();
                }
            });
            
            // Replace content
            info.innerHTML = '';
            info.appendChild(input);
            info.appendChild(saveBtn);
            info.appendChild(cancelBtn);
            
            // Focus input
            setTimeout(() => input.focus(), 10);
        }

        function exitRenameMode(historyItem, nameEl, renameBtn, input, saveBtn, cancelBtn) {
            isRenaming = false; // Re-enable dragging
            const info = historyItem.querySelector('.history-item-info');
            
            // Restore original content
            info.innerHTML = '';
            info.appendChild(nameEl);
            info.appendChild(historyItem.querySelector('.history-item-details'));
            
            // Show original elements
            nameEl.style.display = '';
            renameBtn.style.display = '';
        }

        // Drag and drop functionality
        let draggedElement = null;

        function handleDragStart(e) {
            if (isRenaming) {
                e.preventDefault();
                return;
            }
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragEnd(e) {
            if (isRenaming) return;
            e.target.classList.remove('dragging');
            
            // Remove drag-over class from all items
            document.querySelectorAll('.history-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            
            draggedElement = null;
        }

        function handleDragOver(e) {
            if (isRenaming) {
                e.preventDefault();
                return;
            }
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const target = e.target.closest('.history-item');
            if (target && target !== draggedElement) {
                // Remove drag-over from all items
                document.querySelectorAll('.history-item').forEach(item => {
                    item.classList.remove('drag-over');
                });
                
                // Add drag-over to target
                target.classList.add('drag-over');
            }
        }

        async function handleDrop(e) {
            if (isRenaming) return;
            e.preventDefault();
            
            const target = e.target.closest('.history-item');
            if (!target || target === draggedElement) return;
            
            // Get all history items
            const items = Array.from(historyList.children);
            const draggedIndex = items.indexOf(draggedElement);
            const targetIndex = items.indexOf(target);
            
            // Reorder items in DOM
            if (draggedIndex < targetIndex) {
                target.parentNode.insertBefore(draggedElement, target.nextSibling);
            } else {
                target.parentNode.insertBefore(draggedElement, target);
            }
            
            // Get new order of IDs
            const newOrder = Array.from(historyList.children).map(item => 
                item.dataset.historyId
            );
            
            // Send reorder request to backend
            try {
                const success = await window.electronAPI.reorderHistory(newOrder);
                if (success) {
                    updateStatus('History reordered successfully');
                } else {
                    updateStatus('Failed to reorder history', true);
                    // Reload to restore original order
                    await loadHistory();
                }
            } catch (error) {
                console.error('Failed to reorder:', error);
                updateStatus('Failed to reorder history', true);
                await loadHistory();
            }
        }

        async function clearCache() {
            if (confirm('Are you sure you want to clear the non-starred cache? Starred items will be preserved.')) {
                try {
                    await window.electronAPI.clearCache();
                    await updateCacheInfo();
                    updateStatus('Non-starred cache cleared');
                } catch (error) {
                    console.error('Failed to clear cache:', error);
                    updateStatus('Failed to clear cache', true);
                }
            }
        }

        // Backup management functions
        async function createManualBackup() {
            const backupStatus = document.getElementById('backupStatus');
            try {
                backupStatus.textContent = 'Creating backup...';
                backupStatus.style.color = '#4CAF50';

                // Trigger database save which will create backup automatically
                await saveSettings();

                backupStatus.textContent = 'Backup created successfully!';
                setTimeout(() => {
                    backupStatus.textContent = '';
                }, 3000);

            } catch (error) {
                console.error('Failed to create backup:', error);
                backupStatus.textContent = 'Backup failed!';
                backupStatus.style.color = '#ff6b6b';
                setTimeout(() => {
                    backupStatus.textContent = '';
                }, 3000);
            }
        }

        async function listAvailableBackups() {
            try {
                const backups = await window.electronAPI.listBackups();
                renderBackupList(backups);
            } catch (error) {
                console.error('Failed to list backups:', error);
                updateStatus('Failed to load backup list', true);
            }
        }

        function renderBackupList(backups) {
            const backupList = document.getElementById('backupList');
            const backupItems = document.getElementById('backupItems');

            backupItems.innerHTML = '';

            if (!backups || Object.keys(backups).length === 0) {
                backupItems.innerHTML = '<div style="color: #888; font-style: italic;">No backups found</div>';
                backupList.style.display = 'block';
                return;
            }

            // Render backups for each file type
            Object.keys(backups).forEach(filename => {
                const fileBackups = backups[filename];

                fileBackups.forEach(backup => {
                    const backupItem = document.createElement('div');
                    backupItem.className = 'backup-item';

                    const info = document.createElement('div');
                    info.className = 'backup-info';

                    const filenameEl = document.createElement('div');
                    filenameEl.className = 'backup-filename';
                    filenameEl.textContent = filename;

                    const timestampEl = document.createElement('div');
                    timestampEl.className = 'backup-timestamp';
                    timestampEl.textContent = new Date(backup.timestamp.replace(/-/g, ':')).toLocaleString();

                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'restore-btn';
                    restoreBtn.textContent = 'Restore';
                    restoreBtn.onclick = () => restoreFromBackup(filename, backup.timestamp);

                    info.appendChild(filenameEl);
                    info.appendChild(timestampEl);

                    backupItem.appendChild(info);
                    backupItem.appendChild(restoreBtn);

                    backupItems.appendChild(backupItem);
                });
            });

            backupList.style.display = 'block';
        }

        async function restoreFromBackup(filename, timestamp) {
            if (!confirm(`Are you sure you want to restore ${filename} from the backup dated ${new Date(timestamp.replace(/-/g, ':')).toLocaleString()}? This will overwrite the current ${filename}.`)) {
                return;
            }

            try {
                updateStatus(`Restoring ${filename} from backup...`);
                const success = await window.electronAPI.restoreBackup(filename, timestamp);

                if (success) {
                    updateStatus(`${filename} restored successfully! Please restart the application.`);

                    // Reload the page after a short delay
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                    updateStatus('Failed to restore from backup', true);
                }
            } catch (error) {
                console.error('Failed to restore from backup:', error);
                updateStatus('Failed to restore from backup', true);
            }
        }

        async function toggleHistorySelection(historyId) {
            const wasSelected = selectedHistoryItems.has(historyId);
            
            if (wasSelected) {
                selectedHistoryItems.delete(historyId);
                // Unload the archive from the gallery
                await unloadArchiveFromGallery(historyId);
            } else {
                selectedHistoryItems.add(historyId);
                // Immediately load this archive when checked
                const history = await window.electronAPI.loadHistory();
                const item = history.find(h => h.id === historyId);
                if (item) {
                    try {
                        await loadSingleArchiveToCollection(item);
                    } catch (error) {
                        console.error(`Failed to load ${item.name}:`, error);
                        updateStatus(`Failed to load ${item.name}: ${error.message}`, true);
                        // Remove from selection if it failed to load
                        selectedHistoryItems.delete(historyId);
                    }
                }
            }
            
            updateClearSelectedButton();
            // Update just this checkbox without reloading the entire list
            const historyItem = document.querySelector(`[data-history-id="${historyId}"]`);
            if (historyItem) {
                const checkbox = historyItem.querySelector('.history-checkbox');
                if (selectedHistoryItems.has(historyId)) {
                    checkbox.classList.add('checked');
                } else {
                    checkbox.classList.remove('checked');
                }
            }
        }

        async function unloadArchiveFromGallery(historyId) {
            const history = await window.electronAPI.loadHistory();
            const item = history.find(h => h.id === historyId);
            if (!item) return;
            
            const archiveId = getArchiveIdFromUrl(item.url);
            
            // Remove images from currentImages that belong to this archive
            currentImages = currentImages.filter(img => {
                // Check if image belongs to this archive
                const imageArchiveId = img.id.startsWith('next_') ? img.id.substring(5).split('_')[0] :
                                     img.id.startsWith('prev_') ? img.id.substring(5).split('_')[0] :
                                     img.id.split('_')[0];
                return imageArchiveId !== archiveId && !img.id.startsWith(`${archiveId}_`);
            });
            
            // Remove from loaded archive tracking
            loadedArchiveIds.delete(archiveId);
            
            // If no images left, show welcome screen
            if (currentImages.length === 0) {
                showWelcome();
            } else {
                // Update gallery display with remaining images
                const remainingArchiveNames = [...new Set(currentImages.map(img => img.archiveName).filter(name => name))];
                const displayName = remainingArchiveNames.length === 1 
                    ? remainingArchiveNames[0] 
                    : `${remainingArchiveNames.length} Archives`;
                
                // Reset currentIndex if it's out of bounds
                if (currentIndex >= currentImages.length) {
                    currentIndex = Math.max(0, currentImages.length - 1);
                }
                
                displayGallery(currentImages, displayName);
                await loadHistory(); // Refresh to update highlighting
            }
        }

        async function selectAllHistory() {
            const historyItems = document.querySelectorAll('.history-item');
            historyItems.forEach(item => {
                selectedHistoryItems.add(item.dataset.historyId);
            });
            
            updateClearSelectedButton();
            const history = await window.electronAPI.loadHistory();
            renderHistory(history);
        }

        async function selectNoneHistory() {
            selectedHistoryItems.clear();
            updateClearSelectedButton();
            const history = await window.electronAPI.loadHistory();
            renderHistory(history);
        }

        function updateClearSelectedButton() {
            const clearSelectedBtn = document.getElementById('clearSelectedBtn');
            const selectedCount = selectedHistoryItems.size;
            
            if (selectedCount === 0) {
                clearSelectedBtn.disabled = true;
                clearSelectedBtn.textContent = 'Clear Selected';
            } else {
                clearSelectedBtn.disabled = false;
                clearSelectedBtn.textContent = `Clear Selected (${selectedCount})`;
            }
        }

        async function clearSelectedArchives() {
            // Clear the selections and optionally clear the gallery
            if (selectedHistoryItems.size === 0) return;
            
            selectedHistoryItems.clear();
            loadedArchiveIds.clear();
            
            // Clear the gallery
            showWelcome();
            
            // Refresh history display
            await loadHistory();
            updateClearSelectedButton();
            updateStatus('Cleared selected archives');
        }

        async function loadSingleArchiveToCollection(item) {
            showArchiveLoading();
            updateStatus(`Loading ${item.name}...`);

            try {
                let images = [];
                const archiveId = getArchiveIdFromUrl(item.url);
                
                if (item.url.startsWith('file://')) {
                    images = await window.electronAPI.loadLocalArchive(item.url.replace('file://', ''));
                } else {
                    const result = await window.electronAPI.loadArchive(item.url, settings.cacheSize);
                    images = result.images || [];
                }
                
                if (images.length > 0) {
                    // Add archive name and ID to each image to distinguish them
                    images.forEach(img => {
                        img.archiveName = item.name;
                        img.originalArchiveId = archiveId;
                        img.id = `${archiveId}_${img.id}`; // Prefix with archive ID to avoid conflicts
                    });
                    
                    // If this is the first archive being loaded, replace current images
                    // Otherwise, add to the existing collection
                    if (currentImages.length === 0 || galleryContainer.style.display === 'none') {
                        currentImages = images;
                        loadedArchiveIds.clear();
                        loadedArchiveIds.add(archiveId);
                    } else {
                        // Add to existing collection
                        currentImages = [...currentImages, ...images];
                        loadedArchiveIds.add(archiveId);
                    }
                    
                    // Update gallery display
                    const loadedNames = Array.from(loadedArchiveIds).map(id => {
                        const imgs = currentImages.filter(img => img.id.startsWith(id));
                        return imgs.length > 0 ? imgs[0].archiveName : null;
                    }).filter(name => name);
                    
                    const displayName = loadedNames.length === 1 
                        ? loadedNames[0] 
                        : `${loadedNames.length} Archives`;
                    
                    displayGallery(currentImages, displayName);
                    
                    // Refresh history to show loaded archives
                    await loadHistory();
                    
                    updateStatus(`Added ${images.length} images from ${item.name}`);
                } else {
                    updateStatus(`No images found in ${item.name}`, true);
                }
                
            } catch (error) {
                console.error(`Failed to load ${item.name}:`, error);
                updateStatus(`Failed to load ${item.name}: ${error.message}`, true);
                throw error; // Re-throw so the caller can handle it
            } finally {
                hideArchiveLoading();
            }
        }

        async function loadFromHistory(historyItem) {
            // Clear all selections and start fresh with just this archive
            selectedHistoryItems.clear();
            loadedArchiveIds.clear();
            
            if (historyItem.url.startsWith('file://')) {
                // Local file
                try {
                    const images = await window.electronAPI.loadLocalArchive(historyItem.url.replace('file://', ''));
                    displayGallery(images, historyItem.name);
                    
                    // Update loaded archive tracking
                    const archiveId = getArchiveIdFromUrl(historyItem.url);
                    loadedArchiveIds.add(archiveId);
                    selectedHistoryItems.add(historyItem.id);
                    await loadHistory(); // Refresh to show current archive highlight
                    
                    updateStatus(`Loaded ${images.length} images from cache`);
                } catch (error) {
                    updateStatus(`Error loading from cache: ${error.message}`, true);
                }
            } else {
                // Remote URL
                urlInput.value = historyItem.url;
                await loadArchive();
            }
            historyPanel.classList.remove('open');
        }

        async function updateCacheInfo() {
            try {
                const cacheInfo = await window.electronAPI.getCacheInfo();
                
                document.getElementById('cacheUsed').textContent = formatBytes(cacheInfo.totalSize);
                document.getElementById('cacheAvailable').textContent = formatBytes(settings.cacheSize * 1024 * 1024 * 1024);
                document.getElementById('starredCount').textContent = cacheInfo.starredCount;
                
                const usedPercentage = (cacheInfo.totalSize / (settings.cacheSize * 1024 * 1024 * 1024)) * 100;
                document.getElementById('cacheBarFill').style.width = `${Math.min(usedPercentage, 100)}%`;
                
            } catch (error) {
                console.error('Failed to update cache info:', error);
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function isArchiveUrl(url) {
            return /\.(zip|rar|7z)($|\?|#)/i.test(url) || 
                   (url.includes('.bin?') && /f=[^&]*\.(zip|rar|7z)/i.test(url));
        }

        function isArchiveFile(filename) {
            return /\.(zip|rar|7z)$/i.test(filename);
        }

        function updateStatus(message, isError = false) {
            status.textContent = message;
            status.style.color = isError ? '#ff6b6b' : '#ccc';
        }

        function showLoading(title, text, showProgress = false) {
            loadingTitle.textContent = title;
            loadingText.textContent = text;
            loading.style.display = 'block';
            
            if (showProgress) {
                progressContainer.style.display = 'block';
                progressFill.style.width = '0%';
                progressText.textContent = '0%';
            } else {
                progressContainer.style.display = 'none';
            }
        }

        function hideLoading() {
            loading.style.display = 'none';
            progressContainer.style.display = 'none';
            // Clean up progress listener
            if (window.downloadProgressHandler) {
                window.electronAPI.removeDownloadProgressListener();
                window.downloadProgressHandler = null;
            }
        }

        function updateDownloadProgress(progress) {
            const percentage = Math.round(progress);
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `${percentage}%`;
        }

        async function handleGalleryScroll(e) {
            if (!settings.autoLoadAdjacentArchives || fullscreenOverlay.style.display === 'flex') {
                return; // Don't auto-load in fullscreen mode or if disabled
            }
            
            const scrollElement = e.target.classList.contains('main-content') ? e.target : e.target.closest('.main-content');
            if (!scrollElement) return;
            
            const scrollTop = scrollElement.scrollTop;
            const scrollHeight = scrollElement.scrollHeight;
            const clientHeight = scrollElement.clientHeight;
            const scrollBottom = scrollTop + clientHeight;
            
            // Check if scrolled to near the top (load previous)
            if (scrollTop < 100) {
                const loaded = await loadAdjacentArchive(-1);
                if (loaded) {
                    // Adjust scroll position to account for new content
                    scrollElement.scrollTop = scrollTop + 200;
                }
            }
            // Check if scrolled to near the bottom (load next)
            else if (scrollBottom > scrollHeight - 100) {
                await loadAdjacentArchive(1);
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function showWelcome() {
            welcome.style.display = 'flex';
            galleryContainer.style.display = 'none';
            urlInput.value = '';
            updateStatus('Ready');
            
            // Clean up image URLs
            currentImages.forEach(img => {
                if (img.url && img.url.startsWith('blob:')) {
                    URL.revokeObjectURL(img.url);
                }
            });
            currentImages = [];
            currentArchiveId = null;
            loadedArchiveIds.clear();
            selectedHistoryItems.clear();
            
            // Clean up progress listener
            hideLoading();
        }

        async function loadArchive() {
            if (isArchiveLoading) return; // Prevent multiple concurrent loads
            isArchiveLoading = true;

            const url = urlInput.value.trim();
            if (!url) {
                updateStatus('Please enter an archive URL', true);
                isArchiveLoading = false;
                return;
            }

            if (!isArchiveUrl(url)) {
                updateStatus('URL does not appear to be a supported archive format', true);
                isArchiveLoading = false;
                return;
            }

            try {
                loadBtn.disabled = true;
                showLoading('Downloading Archive', 'This may take a moment for large files...', true);
                updateStatus('Downloading...');

                // Set up download progress listener
                window.downloadProgressHandler = (event, data) => {
                    updateDownloadProgress(data.progress);
                    // Update the loading text with download info
                    const downloadedMB = (data.downloaded / (1024 * 1024)).toFixed(1);
                    const totalMB = (data.total / (1024 * 1024)).toFixed(1);
                    loadingText.textContent = `Downloaded ${downloadedMB} MB of ${totalMB} MB`;
                };
                
                window.electronAPI.onDownloadProgress(window.downloadProgressHandler);

                // Use Electron's main process to download and extract
                const result = await window.electronAPI.loadArchive(url, settings.cacheSize);
                
                if (!result.images || result.images.length === 0) {
                    throw new Error('No images found in archive');
                }

                // Get filename from URL
                let filename = 'Archive';
                try {
                    const urlObj = new URL(url);
                    const fParam = urlObj.searchParams.get('f');
                    if (fParam) {
                        filename = decodeURIComponent(fParam);
                    } else {
                        filename = urlObj.pathname.split('/').pop() || 'Archive';
                    }
                } catch (e) {
                    filename = url.split('/').pop().split('?')[0] || 'Archive';
                }

                hideLoading();
                displayGallery(result.images, filename);
                
                // Clear and update loaded archive tracking
                selectedHistoryItems.clear();
                loadedArchiveIds.clear();
                loadedArchiveIds.add(result.archiveId);
                currentArchiveId = result.archiveId;
                
                await addToHistory(filename, url, result.images.length);
                
                // Add the new archive to selections and refresh history
                const history = await window.electronAPI.loadHistory();
                const newHistoryItem = history.find(item => item.url === url);
                if (newHistoryItem) {
                    selectedHistoryItems.add(newHistoryItem.id);
                }
                
                await loadHistory(); // Refresh to show current archive highlight
                await updateCacheInfo();
                updateStatus(`Loaded ${result.images.length} images`);

            } catch (error) {
                hideLoading();
                updateStatus(`Error: ${error.message}`, true);
                console.error('Archive loading error:', error);
            } finally {
                loadBtn.disabled = false;
                isArchiveLoading = false;
                // Clean up progress listener
                if (window.downloadProgressHandler) {
                    window.electronAPI.removeDownloadProgressListener();
                    window.downloadProgressHandler = null;
                }
            }
        }

        function displayGallery(images, filename) {
            currentImages = images;
            currentIndex = 0; // Reset to first image
            
            // Update UI
            welcome.style.display = 'none';
            galleryContainer.style.display = 'block';
            
            // Check if we have multiple archives loaded
            const hasMultipleArchives = images.some(img => img.archiveName);
            if (hasMultipleArchives) {
                const archiveNames = [...new Set(images.map(img => img.archiveName).filter(name => name))];
                archiveTitle.textContent = `ðŸ“¦ ${archiveNames.join(', ')} (${images.length} images)`;
            } else {
                archiveTitle.textContent = `ðŸ“¦ ${filename} (${images.length} images)`;
            }
            
            // Clear and populate gallery
            galleryGrid.innerHTML = '';
            galleryGrid.style.gridTemplateColumns = `repeat(${columnSlider.value}, 1fr)`;
            
            images.forEach((image, index) => {
                const container = document.createElement('div');
                container.className = 'image-container';
                container.style.position = 'relative';
                
                const img = document.createElement('img');
                img.src = image.url;
                img.alt = image.name;
                img.title = image.archiveName ? `${image.archiveName} - ${image.name}` : image.name;
                img.loading = 'lazy';
                
                const starBtn = document.createElement('button');
                starBtn.className = `star-btn ${image.starred ? 'starred' : ''}`;
                starBtn.innerHTML = image.starred ? 'â˜…' : 'â˜†';
                starBtn.title = image.starred ? 'Remove from favorites' : 'Add to favorites';
                starBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Extract the archive ID from the image ID if it's prefixed
                    let archiveId = currentArchiveId;
                    if (image.originalArchiveId) {
                        archiveId = image.originalArchiveId;
                    } else if (image.id.includes('_')) {
                        // Try to extract archive ID from prefixed image ID
                        const parts = image.id.split('_');
                        if (parts.length > 1) {
                            archiveId = parts[0];
                        }
                    }
                    toggleImageStar(image.id, starBtn, archiveId);
                };
                
                img.addEventListener('click', () => openFullscreen(index));
                img.addEventListener('mouseenter', () => applyHoverZoom(img));
                img.addEventListener('mouseleave', () => removeHoverZoom(img));
                
                container.appendChild(img);
                container.appendChild(starBtn);
                galleryGrid.appendChild(container);
            });
        }

        async function toggleImageStar(imageId, starBtn, archiveId) {
            console.log(`=== FRONTEND STAR TOGGLE ===`);
            console.log(`Image ID: ${imageId}`);
            console.log(`Archive ID: ${archiveId || currentArchiveId}`);
            console.log(`Current Images Count: ${currentImages.length}`);

            const actualArchiveId = archiveId || currentArchiveId;
            
            try {
                console.log(`Calling window.electronAPI.toggleImageStar(${actualArchiveId}, ${imageId})`);
                const result = await window.electronAPI.toggleImageStar(actualArchiveId, imageId);
                console.log(`Backend result:`, result);

                starBtn.className = `star-btn ${result.starred ? 'starred' : ''}`;
                starBtn.innerHTML = result.starred ? 'â˜…' : 'â˜†';
                starBtn.title = result.starred ? 'Remove from favorites' : 'Add to favorites';

                // Update current images array
                const image = currentImages.find(img => img.id === imageId);
                if (image) {
                    image.starred = result.starred;
                    console.log(`Updated local image.starred to: ${result.starred}`);
                } else {
                    console.log(`WARNING: Could not find image ${imageId} in currentImages array`);
                }

                await updateCacheInfo();
                console.log(`=== FRONTEND STAR TOGGLE COMPLETE ===`);
            } catch (error) {
                console.error('Failed to toggle image star:', error);
            }
        }

        function updateFullscreenUpscaling() {
            const fullscreenImage = document.getElementById('fullscreenImage');
            if (settings.allowFullscreenUpscaling) {
                fullscreenImage.classList.add('allow-upscaling');
            } else {
                fullscreenImage.classList.remove('allow-upscaling');
            }
        }

        function updateZoomSliderMax() {
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');
            
            if (settings.allowFullscreenUpscaling) {
                // Allow up to 500% when upscaling is enabled
                zoomSlider.max = 500;
                zoomValue.textContent = zoomSlider.value + '%';
            } else {
                // Limit to 200% when upscaling is disabled
                zoomSlider.max = 200;
                if (parseInt(zoomSlider.value) > 200) {
                    zoomSlider.value = 200;
                    zoomValue.textContent = '200%';
                }
            }
        }

        function applyHoverZoom(img) {
            const scale = zoomSlider.value / 100;
            img.style.transform = `scale(${scale})`;
            img.style.zIndex = '100';
            img.style.position = 'relative';
        }

        function removeHoverZoom(img) {
            img.style.transform = 'scale(1)';
            img.style.zIndex = 'auto';
            img.style.position = 'static';
        }

        function openFullscreen(index) {
            if (!currentImages[index]) return;
            
            currentIndex = index;
            fullscreenImage.src = currentImages[index].url;
            
            // Apply upscaling class if enabled
            updateFullscreenUpscaling();
            
            updateFullscreenCounter();
            fullscreenOverlay.style.display = 'flex';
        }

        function closeFullscreen() {
            fullscreenOverlay.style.display = 'none';
        }

        function updateFullscreenCounter() {
            if (fullscreenCounter && currentImages.length > 0) {
                fullscreenCounter.textContent = `${currentIndex + 1} / ${currentImages.length}`;
            }
        }

        async function navigateFullscreen(direction) {
            console.log(`navigateFullscreen: direction=${direction}, currentIndex=${currentIndex}, totalImages=${currentImages.length}`);
            
            const newIndex = currentIndex + direction;
            
            // Check if we're at boundaries and auto-load is enabled
            if (newIndex < 0 && settings.autoLoadAdjacentArchives) {
                console.log('At start boundary, trying to load previous archive');
                // Try to load previous archive
                const loaded = await loadAdjacentArchive(-1);
                if (loaded) {
                    console.log(`Previous archive loaded. New currentIndex=${currentIndex}, totalImages=${currentImages.length}`);
                    // Now try to navigate to the previous image
                    const finalIndex = currentIndex - 1;
                    if (finalIndex >= 0) {
                        currentIndex = finalIndex;
                        fullscreenImage.src = currentImages[currentIndex].url;
                        updateFullscreenCounter();
                        updateStatus(`Image ${currentIndex + 1} of ${currentImages.length}`);
                    }
                    return;
                }
            } else if (newIndex >= currentImages.length && settings.autoLoadAdjacentArchives) {
                console.log('At end boundary, trying to load next archive');
                // Try to load next archive
                const loaded = await loadAdjacentArchive(1);
                if (loaded) {
                    console.log(`Next archive loaded. New currentIndex=${currentIndex}, totalImages=${currentImages.length}`);
                    // Now navigate to the first image of the newly loaded archive
                    currentIndex = newIndex;
                    fullscreenImage.src = currentImages[currentIndex].url;
                    updateFullscreenCounter();
                    updateStatus(`Image ${currentIndex + 1} of ${currentImages.length}`);
                    return;
                }
            }
            
            // Normal navigation
            if (newIndex >= 0 && newIndex < currentImages.length) {
                currentIndex = newIndex;
                fullscreenImage.src = currentImages[currentIndex].url;
                updateFullscreenCounter();
                updateStatus(`Image ${currentIndex + 1} of ${currentImages.length}`);
            }
        }

        function showArchiveLoading() {
            archiveLoading.style.display = 'block';
        }

        function hideArchiveLoading() {
            archiveLoading.style.display = 'none';
        }

        async function findAdjacentArchive(direction) {
            try {
                const history = await window.electronAPI.loadHistory();
                if (!history || history.length === 0) return null;

                // When multiple archives are loaded, we need to handle this differently
                if (loadedArchiveIds.size > 1) {
                    // Find the boundary archive based on direction
                    let boundaryItem = null;
                    let boundaryIndex = direction > 0 ? -1 : history.length;
                    
                    // Find the most extreme loaded archive in the history
                    for (const archiveId of loadedArchiveIds) {
                        const item = history.find(h => getArchiveIdFromUrl(h.url) === archiveId);
                        if (item) {
                            const itemIndex = history.indexOf(item);
                            if (direction > 0 && itemIndex > boundaryIndex) {
                                boundaryIndex = itemIndex;
                                boundaryItem = item;
                            } else if (direction < 0 && itemIndex < boundaryIndex) {
                                boundaryIndex = itemIndex;
                                boundaryItem = item;
                            }
                        }
                    }
                    
                    if (!boundaryItem) return null;
                    
                    // Find adjacent to the boundary
                    const adjacentIndex = boundaryIndex + direction;
                    if (adjacentIndex >= 0 && adjacentIndex < history.length) {
                        const adjacentItem = history[adjacentIndex];
                        // Don't load if it's already loaded
                        const adjacentId = getArchiveIdFromUrl(adjacentItem.url);
                        if (loadedArchiveIds.has(adjacentId)) {
                            return null; // Already loaded
                        }
                        return adjacentItem;
                    }
                } else {
                    // Single archive loaded - use the current approach
                    const currentItem = history.find(item => 
                        getArchiveIdFromUrl(item.url) === currentArchiveId
                    );
                    
                    if (!currentItem) return null;
                    
                    // Find adjacent item
                    const currentIndex = history.indexOf(currentItem);
                    const adjacentIndex = currentIndex + direction;
                    
                    if (adjacentIndex >= 0 && adjacentIndex < history.length) {
                        return history[adjacentIndex];
                    }
                }
            } catch (error) {
                console.error('Failed to find adjacent archive:', error);
            }
            return null;
        }

        async function loadAdjacentArchive(direction) {
            console.log(`loadAdjacentArchive: direction=${direction}, autoLoad=${settings.autoLoadAdjacentArchives}`);
            
            if (!settings.autoLoadAdjacentArchives || isArchiveLoading) return false;
            if (isArchiveLoading) return false; // Prevent multiple concurrent loads
            
            isArchiveLoading = true;
            
            try {
                const adjacentItem = await findAdjacentArchive(direction);
                if (!adjacentItem) {
                    console.log('No adjacent archive found');
                    return false;
                }
                console.log(`Found adjacent archive: ${adjacentItem.name}`);
                showArchiveLoading();
                
                let newImages = [];
                const newArchiveId = getArchiveIdFromUrl(adjacentItem.url);
                
                if (adjacentItem.url.startsWith('file://')) {
                    // Local file
                    newImages = await window.electronAPI.loadLocalArchive(adjacentItem.url.replace('file://', ''));
                } else {
                    // Remote URL
                    const result = await window.electronAPI.loadArchive(adjacentItem.url, settings.cacheSize);
                    newImages = result.images || [];
                }
                
                console.log(`Loaded ${newImages.length} images from adjacent archive`);

                if (newImages && newImages.length > 0) {
                    // Add archive info to avoid ID conflicts
                    newImages.forEach(img => {
                        img.id = `${newArchiveId}_${img.id}`;
                        img.archiveName = adjacentItem.name;
                        img.originalArchiveId = newArchiveId;
                    });

                    const oldCurrentIndex = currentIndex;
                    const oldTotalImages = currentImages.length;
                    
                    // Merge images based on direction
                    if (direction > 0) {
                        // Next archive - append to end
                        currentImages = [...currentImages, ...newImages];
                        console.log(`Appended ${newImages.length} images. currentIndex stays ${currentIndex}`);
                    } else {
                        // Previous archive - prepend to beginning
                        currentImages = [...newImages, ...currentImages];
                        currentIndex += newImages.length;
                        console.log(`Prepended ${newImages.length} images. currentIndex changed from ${oldCurrentIndex} to ${currentIndex}`);
                    }

                    // Add to loaded archives tracking
                    loadedArchiveIds.add(newArchiveId);
                    
                    // Auto-check the checkbox for this archive
                    const history = await window.electronAPI.loadHistory();
                    const historyItem = history.find(h => h.url === adjacentItem.url);
                    if (historyItem) {
                        selectedHistoryItems.add(historyItem.id);
                    }
                    
                    // Update current archive info for highlighting
                    currentArchiveId = newArchiveId;
                    
                    // Update gallery title to show all loaded archives
                    const archiveNames = [...new Set(currentImages.map(img => img.archiveName).filter(name => name))];
                    const displayName = archiveNames.length === 1 
                        ? archiveNames[0] 
                        : `${archiveNames.length} Archives`;
                    
                    displayGallery(currentImages, displayName);

                    // Refresh history to show current highlight and checked state
                    await loadHistory();

                    updateStatus(`Auto-loaded: ${adjacentItem.name} (${newImages.length} images)`);
                    console.log(`loadAdjacentArchive complete: totalImages=${currentImages.length}, currentIndex=${currentIndex}`);
                    return true;
                }
            } catch (error) {
                console.error('Error in loadAdjacentArchive:', error);
                updateStatus(`Failed to load adjacent archive: ${error.message}`, true);
            } finally {
                hideArchiveLoading();
                isArchiveLoading = false;
            }
            
            return false;
        }

        function handleKeyboard(e) {
            if (fullscreenOverlay.style.display === 'flex') {
                switch (e.key) {
                    case 'Escape':
                        e.preventDefault();
                        closeFullscreen();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigateFullscreen(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        navigateFullscreen(1);
                        break;
                }
            } else if (galleryContainer.style.display === 'block') {
                // Gallery view navigation
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigateGallery(-1);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        navigateGallery(1);
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (currentImages[currentIndex]) {
                            openFullscreen(currentIndex);
                        }
                        break;
                }
            }
        }

        async function navigateGallery(direction) {
            const newIndex = currentIndex + direction;
            
            // Check if we're at boundaries and auto-load is enabled
            if (newIndex < 0 && settings.autoLoadAdjacentArchives) {
                // Try to load previous archive
                const loaded = await loadAdjacentArchive(-1);
                if (loaded) {
                    // Navigation will be handled by the load function
                    return;
                }
            } else if (newIndex >= currentImages.length && settings.autoLoadAdjacentArchives) {
                // Try to load next archive
                const loaded = await loadAdjacentArchive(1);
                if (loaded) {
                    // Navigation will be handled by the load function
                    return;
                }
            }
            
            // Normal navigation
            if (newIndex >= 0 && newIndex < currentImages.length) {
                currentIndex = newIndex;
                scrollToImage(currentIndex);
                updateStatus(`Image ${currentIndex + 1} of ${currentImages.length}`);
            }
        }

        function scrollToImage(index) {
            const imageContainers = galleryGrid.querySelectorAll('.image-container');
            if (imageContainers[index]) {
                imageContainers[index].scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                });
                
                // Add temporary highlight effect
                imageContainers[index].style.boxShadow = '0 0 0 3px #4CAF50';
                setTimeout(() => {
                    imageContainers[index].style.boxShadow = '';
                }, 1000);
            }
        }
    </script>
</body>
</html>